/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package LivenessDetect;

import ai.djl.*;
import ai.djl.inference.*;
import ai.djl.modality.cv.Image;
import ai.djl.modality.cv.util.NDImageUtils;
import ai.djl.ndarray.*;
import ai.djl.translate.*;

import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LivenessDetector {
	private static final Logger logger = LoggerFactory.getLogger(LivenessDetector.class);
	private static final String modelFile = "liveness_model.pt";
	private String modelDir = "/home/maxim/model/";
	
    static Predictor<Image, Float> predictor=null;
    static Model model = null;

    public LivenessDetector() { }
    
    public LivenessDetector(String modelDir) throws MalformedModelException, IOException
    {
    	this.modelDir = modelDir;
    }
    
    public boolean init() 
	{
    	// https://github.com/deepjavalibrary/djl/issues/147
    	// http://docs.djl.ai/docs/load_model.html#implement-your-own-repository
		try {
    		File dir = new File(modelDir);
    		if (!dir.exists()) {
    			System.out.println("Invalid model dir, " + modelDir);
    			logger.debug("Invalid model dir, " + modelDir);
    			return false;
    		}
    		if(!dir.isDirectory()) {
    			System.out.println("Please specify full path of model directory, not file, " + modelDir);
    			logger.debug("Please specify full path of model directory, not file, " + modelDir);
    			return false;
    		}
        	// This is not work when model is located in the fatjar
	    	// ClassPathResource resource = new ClassPathResource(MODEL_FILE_NAME)
			// the directory of the file (in the case the file is local, this should also return absolute directory)
			// Path modelDir = Paths.get(resource.getFile().getAbsoluteFile().getParent());
    		
    		// load the PyTorch model.
			// pytorch gpu api > 0.5 requires gpu compute capability > 3.7, so use cpu for Geforce GT 730 gpu
    		Path path = Paths.get(modelDir);
			model = Model.newInstance(modelFile, Device.cpu(), "PyTorch"); 
			model.load(path, modelFile);
			//create the predictor
			Translator<Image, Float>  translator = new Translator<Image, Float>() {
				@Override
				public NDList processInput(TranslatorContext ctx, Image input) throws Exception {
					NDManager manager = ctx.getNDManager();
					NDArray imageND1 = input.toNDArray(manager);
					NDArray imageND2 = NDImageUtils.resize(imageND1, 480, 480);
					NDArray imageND3 = imageND2.transpose(2, 0, 1).flip(0); // HWC->CHW BGR->RGB
					NDArray imageND4 = NDImageUtils.normalize(imageND3,
							new float[] {117f, 123f, 104f}, // BGR<->RGB exchanged?
							new float[] {57f, 58f, 57f});	// BGR<->RGB exchanged?
					return new NDList(imageND4);
				}

				@Override
				public Float processOutput(TranslatorContext ctx, NDList list) throws Exception {
					NDArray pred = list.get(0);
					float x = pred.getFloat(0);
					// get sigmoid
			        double d = 1+ Math.exp(-x);
			        float result = 1/(float)d;
					return result;
				}
	
				@Override
				public Batchifier getBatchifier() {
					return Batchifier.STACK;
				}   
			};
			predictor = model.newPredictor(translator);
    	}
    	catch(Exception e)
    	{
    		e.printStackTrace();
    		logger.debug(e.toString());
    		return false;
    	}
		return true;
	}
	
    public boolean detectLiveness(Image img)
    {
		float res;
		try {
			res = predictor.predict(img);
			System.out.println("fake score = " + Float.toString(res));
			logger.info("fake score = " + Float.toString(res));
			if (res < 0.45) return true;
			else return false;
		} catch (TranslateException e) {
			e.printStackTrace();
			return false;
		}
    }
}